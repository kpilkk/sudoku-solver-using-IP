# -*- coding: utf-8 -*-
"""Sudoku Image Preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18_u5UfVnSxZ-xsUOaLUnJh9e6QfBo86X
"""

import matplotlib.pyplot as plt
import numpy as np
import math
import operator
import os
import cv2

'''
from google.colab import drive
drive.mount('/content/gdrive/')
'''

def getcontourorder(contour):
  loc = cv2.boundingRect(contour)
  return math.floor(loc[1]/20)*2000+loc[0]

def l2_dist(pt1,pt2):
  return np.sqrt((pt2[0]-pt1[0])**2 + (pt2[1]-pt1[1])**2)

def sudoku_extractor(img_name):
  
  img_path = os.getcwd() + '/images/' + img_name
  print(img_path)
  img = cv2.imread(img_path)
  cv2.imshow('image',img)
  cv2.waitKey()

  gray = cv2.cvtColor(img.copy(),cv2.COLOR_BGR2GRAY)
  gray.shape

  if max(gray.shape[0],gray.shape[1])>500:
    blurred = cv2.GaussianBlur(gray.copy(), (9,9),0)
    blurred.shape
    plt.imshow(blurred)
  else:
    blurred = gray.copy()

  #print(blurred.shape)

  #cv2.imshow('blurredd',blurred)
  #cv2.waitKey()
  thresh = cv2.adaptiveThreshold(blurred.copy(),255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV,7,2 )
  #cv2.imshow('thresh',thresh)
  #cv2.waitKey()
  conts, heirarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  #cv2.imshow('img',cv2.drawContours(img.copy(), conts, -1, (0, 255, 0), 1) )
  #cv2.waitKey()
  conts = sorted(conts, key=cv2.contourArea, reverse=True)

  cont = conts[0]
  #cv2.imshow('rand',cv2.drawContours(img.copy(), cont,0, (0,255,0), 50) )
  #cv2.waitKey()
  bottom_right, _ = max(enumerate([pt[0][0] + pt[0][1] for pt in cont]), key=operator.itemgetter(1))
  top_left, _ = min(enumerate([pt[0][0] + pt[0][1] for pt in cont]), key=operator.itemgetter(1))
  bottom_left, _ = min(enumerate([pt[0][0] - pt[0][1] for pt in cont]), key=operator.itemgetter(1))
  top_right, _ = max(enumerate([pt[0][0] - pt[0][1] for pt in cont]), key=operator.itemgetter(1))

  cont[top_left][0], cont[top_right][0], cont[bottom_right][0], cont[bottom_left][0]

  plt.scatter( cont[top_left][0][0],cont[top_left][0][1])
  plt.scatter( cont[top_right][0][0],cont[top_right][0][1])
  plt.scatter( cont[bottom_left][0][0],cont[bottom_left][0][1])
  plt.scatter( cont[bottom_right][0][0],cont[bottom_right][0][1])

  #cv2.imshow('rand',cv2.drawContours(gray.copy(),cont,-1,(0,0,255),5))
  #cv2.waitKey()
  original_rect = np.array([cont[top_left][0],cont[top_right][0],cont[bottom_right][0],cont[bottom_left][0]],dtype='float32')

  topleft,topright,bottomright,bottomleft = original_rect

  maxlen = int(max(l2_dist(topleft,topright),l2_dist(topright,bottomright),l2_dist(bottomright,bottomleft),l2_dist(bottomleft,topright)))
  #print(maxlen)

  #target_rect = np.array([ [0,maxlen-1], [maxlen-1,maxlen-1], [0,maxlen-1],[0,0] ], dtype='float32')
  target_rect = np.array([ [0,0], [maxlen,0] ,[maxlen,maxlen],[0,maxlen]] , dtype='float32')

  M = cv2.getPerspectiveTransform(original_rect,target_rect)

  warped = cv2.warpPerspective(blurred.copy(), M, (maxlen,maxlen) )
  #cv2.imshow(warped)

  warped2 = warped[3:maxlen-3,3:maxlen-3]
  #cv2.imshow(warped2)

  boxlen = int(maxlen/9)
  #print('boxlen : ',boxlen)

  boxdims = [int(n) for n in np.linspace(0,maxlen,10)]
  #print('boxdim : ',boxdims)


  #print(os.getcwd()+'/utils/numbers.jpg')
  numbers_template = cv2.imread(os.getcwd()+'/utils/numbers.jpg',0)

  #cv2.imshow('num',numbers_template)
  #cv2.waitKey()
  template_conts, heirarchy = cv2.findContours(numbers_template, cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)

  template_conts = sorted(template_conts, key=cv2.contourArea, reverse=True)
  template_conts= template_conts[:10]

  template_conts = sorted(template_conts, key=lambda x:getcontourorder(x))

  #cv2.imshow(cv2.drawContours(numbers_template.copy(), template_conts[9],-1, (255,255,255), 10) )

  digits={}

  for (i,c) in enumerate(template_conts):
    (x,y,w,h)=cv2.boundingRect(c)
    roi = numbers_template[y:y+h ,x:x+w]
    roi = cv2.resize(roi,(35,60))
    digits[i]=roi

  #for i in range(len(digits)):
  #  cv2.imshow(str(i),digits[i])
  #  cv2.waitKey()

  config = ("-l eng --oem 1 --psm 10")

  matrix=[]
  row=[]
  kernelsize = int(maxlen/4)
  if kernelsize%2==0:
    kernelsize+=1
  for y in range(len(boxdims)-1):
    row=[]
    for x in range(len(boxdims)-1):
      x1 = boxdims[x]
      x2 = boxdims[x+1]
      y1 = boxdims[y]
      y2 = boxdims[y+1]
      
      roi = warped2[y1:y2, x1:x2]

      roithresh = cv2.adaptiveThreshold(roi,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV,kernelsize,2 )

      max_area=boxlen*boxlen*0.05
      seed_point = (int(0.5*boxlen), int(0.5*boxlen))
      flag=0

      for m in range(int(0.3*boxlen), int(0.7*boxlen)):
        for n in range(int(0.3*boxlen), int(0.7*boxlen)):
          if roithresh[n, m] == 255:  
            area = cv2.floodFill(roithresh.copy(), None, (m, n), 150)
            if area[0] > max_area: 
              max_area = area[0]
              seed_point = (m, n)
              flag=1

      if (roithresh[seed_point[1],seed_point[0]]==0) or flag==0:
        num=0
      else:
        flood=0
        flood = cv2.floodFill(roithresh.copy(),None,seed_point,150)

        canvas = roithresh.copy()
        for i in range(canvas.shape[0]):
          for j in range(canvas.shape[1]):
              if flood[1][i][j]==150:
                canvas[i][j]=255
              else:
                canvas[i][j]=0  

        contour = cv2.findContours(canvas,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
        contour = contour[0]
        (box_x,box_y,box_w,box_h) =cv2.boundingRect(contour[0])
        isolated_digit = canvas[box_y:box_y+box_h ,box_x:box_x+box_w]
        isolated_digit = cv2.resize(isolated_digit,(35,60))
        #print('isolated_digit : ',isolated_digit)

        scores=[]
        for (digit,digit_template) in digits.items():
          result = cv2.matchTemplate(isolated_digit, digit_template,cv2.TM_CCOEFF)
          (_,score,_,_) = cv2.minMaxLoc(result)
          scores.append(score)
        #print(scores)
        num = np.argmax(scores)

      row.append(num)
    matrix.append(row)
  return matrix
  #print(matrix)
  #cv2.imshow('img',img)
  #cv2.waitKey()
